[
["index.html", "Handling Strings With R r4strings Full Edition Preview Edition", " Handling Strings With R Gaston Sanchez r4strings Full Edition The full edition (in PDF and EPUB formats) can be purchased at leanpub: https://leanpub.com/r4strings Preview Edition This is now a preview of the first four chapters: I Characters and Strings in R Introductory Appetizer Character Strings in R Basic Manipulations With “base” Functions Basic Manipulations With “stringr” Functions II Printing and Formatting Formatting Text and Numbers C-Style Formatting Input and Output III Regular Expressions Getting Started with Regular Expressions Character Sets Anchors and Quantifiers Boundaries and Look Arounds Regex Functions in R IV Applications Plots Basic Examples Matching HTML Tags Data Cleaning Log File Text Analysis of BioMed Central Journals Sentiments in Tweets "],
["preface.html", "Preface", " Preface Handling character strings in R? Wait a second… you exclaim, R is not a scripting language like Perl, Python, or Ruby. Why would you want to use R for handling and processing text? Well, because sooner or later (I would say sooner than later) you will have to deal with some kind of string manipulation for your data analysis. So it’s better to be prepared for such tasks and know how to perform them inside the R environment. If you have been formed and trained in “classical statistics” (as I was), I bet you probably don’t think of character strings as data that can be analyzed. The bottom line for your analysis is numbers or things that can be mapped to numeric values. Text and character strings? Really? Are you kidding me? … That’s what I used to think right after finishing college. During my undergraduate studies in statistics, none of my professors mentioned analysis applications with strings and text data. It was years later, in grad school, when I got the chance to be marginally involved with some statistical text analysis. Perhaps even worse is the not so uncommon believe that string manipulation is a secondary non-relevant task. People will be impressed and will admire you for any kind of fancy model, sophisticated algorithms, and black-box methods that you get to apply. Everybody loves the haute cuisine of data analysis and the top notch analytics. But when it comes to processing and manipulating strings, many will think of it as washing the dishes or pealing and cutting potatos. If you want to be perceived as a data chef, you may be tempted to think that you shouldn’t waste your time in those boring tasks of manipulating strings. Yes, it is true that you won’t get a Michelin star for processing character data. But you would hardly become a good data cook if you don’t get your hands dirty with string manipulation. And to be honest, it’s not always that boring. Whether you like it or not, no one should ever claim to be a data analyst until he or she has done some manipulation of strings. You don’t have to be an expert or some string processing hacker though. But you do need to know the basics and have an idea on how to proceed in case you need to play with text-character-string data. Text Is Omnipresent At its heart, computing involves working with numbers. That’s the main reason why computers were invented: to facilitate mathematical operations around numbers; from basic arithmetic to more complex operations (e.g. trigonometry, algebra, calculus, etc.) Nowadays, however, we use computers to work with data that are not just numbers. We use them to write a variety of documents, we use them to create and edit images and videos, to manipulate sound, among many other tasks. Learning to manipulate those data types is fundamental to programming. Just think about it. Today, there is a considerable amount of information and data in the form of text. Look at any website: pretty much the contents are text and images, with some videos here and there, and maybe some tables and/or a list of numbers. Likewise, most of the times you are going to be working with text files: script files, reports, data files, source code files, etc. All the R script files that you use are essentially plain text files. I bet you have a csv file or any other field delimited format (or even in HTML, XML, JSON, etc), with some fields containing characters. In all of these cases what you are working with is essentially a bunch of characters. And then inside R you also have text. Things like row names and column names of matrices, data frames, tables, and any other rectangular data structure. Lists and vectors may also contain names. And what about the text in graphics? Things like titles, subtitles, axis labels, legends, colors, displayed text in a plot, etc. At the end of the day all the data that is passed to the computer is converted to binary format (zeros and ones) so computers can process it. But no one can deny the fact that a lot of what we do with computers is working with text and character strings. Text is omnipresent. Whether you are aware of this or not, we are surrounded by text. About This Book This book aims to help you get started with manipulating strings in R. What type of manipulations am I talking about? For example, I’m sure that you have encountered one or more of the following cases: You want to remove a given character in the names of your variables You want to replace a given character in your data Maybe you wanted to convert labels to upper case (or lower case) You’ve been struggling with xml (or html) files You’ve been modifying text files in excel changing labels, categories, one cell at a time, or doing one thousand copy-paste operations The content of the book is divided in four major parts: Characters and Strings in R Printing and Formatting Regular Expressions Applications If you have minimal or none experience with R, the best place to start is Chapter 2: Character Strings in R. If you are already familiar with the basics of vectors and character objects, you can quickly skim this chapter, or skip it, and then go to another chapter of your interest. Chapters 3 and 4 deal with basic string manipulations. By “basic” I mean any type of manipulation and transformation that does not require the use of regular expressions. The second part of the book describes different ways to format text and numbers. These are useful tools for when you want to produce output that will either be displayed on screen, or that will be exported to a file. The third part comprises working with regular expressions (regex). Here you will learn about the basic concepts around regular expressions (regex), the intricacies when working with regex in R, and becoming familiar with the regex functions in the R package \"stringr\". Last but not least, the fourth part of the book present a couple of case studies and extended practical examples that cover the main topics covered in the book. Having said that, I should say that this book is NOT about textual data analysis, linguistic analysis, text mining, or natural language processing. About the Reader I am assuming three things about you. In decreasing order of importance: You already know R—this is not an introductory text on R. You already use R for handling quantitative and qualitative data, but not (necessarily) for processing strings. You have some basic knowledge about Regular Expressions. Main Resources I should also say that this work is my third iteration on the subject of manipulating strings, text and character data in R. I started writing the draft of my first manuscript around 2012 when there was not much documentation on how to manipulate character strings in R. Although the number of resources about this subject has increased since then, the pace of these changes has been considerably slow. What I wrote eight years ago is still valid today. There is not much documentation on how to manipulate character strings and text data in R. There are great R books for an enormous variety of statistical methods, graphics and data visualization, as well as applications in a wide range of fields such as ecology, genetics, psychology, finance, economics, etc. But not much for manipulating strings and text data. I still believe that the main reason for this lack of resources is that R is not considered to be qualified as a “scripting” language: R is primarily perceived as a language for computing and programming with (mostly numeric) data. Quoting Hadley Wickham (2010) http://journal.r-project.org/archive/2010-2/RJournal_2010-2_Wickham.pdf “R provides a solid set of string operations, but because they have grown organically over time, they can be inconsistent and a little hard to learn. Additionally, they lag behind the string operations in other programming languages, so that some things that are easy to do in languages like Ruby or Python are rather hard to do in R” Most introductory books about R have small sections that briefly cover string manipulation without going further down. That is why I don’t have many books for recommendation, if anything the book by Phil Spector Data Manipulation with R. If published material is not abundant, we still have the online world. The good news is that the web is full of hundreds of references about processing character strings. The bad news is that they are very spread and uncategorized. For specific topics and tasks, a good place to start with is Stack Overflow. This is a questions-and-answers site for programmers that has a lot of questions related with R. Just look for those questions tagged with \"r\": http://stackoverflow.com/questions/tagged/r. There is a good number of posts related with handling characters and text, and they can give you a hint on how to solve a particular problem. There is also R-bloggers, http://www.r-bloggers.com, a blog aggregator for R enthusiasts in which is also possible to find contributed material about processing strings as well as text data analysis. You can also check the following resources that have to do with string manipulations. It is a very short list of resources but I’ve found them very useful: R Wikibook: Programming and Text Processing http://en.wikibooks.org/wiki/R_Programming/Text_Processing R wikibook has a section dedicated to text processing that is worth check it out. stringr: modern, consisting string processing by Hadley Wickham http://journal.r-project.org/archive/2010-2/RJournal_2010-2_Wickham.pdf Article from the R journal introducing the package \"stringr\" by Hadley Wickham. Introduction to String Matching and Modification in R Using Regular Expressions by Svetlana Eden http://biostat.mc.vanderbilt.edu/wiki/pub/Main/SvetlanaEdenRFiles/regExprTalk.pdf For things such as textual data analysis, linguistic analysis, text mining, or natural language processing, I highly recommend you to take a look at the CRAN Task View on Natural Language Processing (NLP): http://cran.r-project.org/web/views/NaturalLanguageProcessing.html While it is true that R may not be as rich and diverse as other scripting languages when it comes to string manipulation, I’m one of those who believe it can take you very far if you know how. By writing this book, my goal is to provide you enough material to do more advanced string and text processing operations. My hope is that, after reading this book, you will have the necessary tools in your toolbox for dealing with these (and many) other situations that involve handling and processing strings in R. Citation You can cite this work as: Sanchez, G. (2021) Handling Strings With R Trowchez Editions. Berkeley, 2021. "],
["intro.html", "1 Introductory Appetizer 1.1 A Toy Example", " 1 Introductory Appetizer To give you an idea of some of the things we can do in R with string processing, let’s play a bit with a simple example. 1.1 A Toy Example For this crash informal introduction, we’ll use the data frame USArrests that already comes with R. Use the function head() to get a peek of the data: # take a peek of USArrests head(USArrests) #&gt; Murder Assault UrbanPop Rape #&gt; Alabama 13.2 236 58 21.2 #&gt; Alaska 10.0 263 48 44.5 #&gt; Arizona 8.1 294 80 31.0 #&gt; Arkansas 8.8 190 50 19.5 #&gt; California 9.0 276 91 40.6 #&gt; Colorado 7.9 204 78 38.7 The labels on the rows such as Alabama or Alaska are displayed strings. Likewise, the labels of the columns—Murder, Assault, UrbanPop and Rape—are also strings. 1.1.1 Abbreviating strings Suppose we want to abbreviate the names of the States. Furthermore, suppose we want to abbreviate the names using the first four characters of each name. One way to do that is by using the function substr() which substrings a character vector. We just need to indicate the start=1 and stop=4 positions: # names of states states &lt;- rownames(USArrests) # substr substr(x = states, start = 1, stop = 4) #&gt; [1] &quot;Alab&quot; &quot;Alas&quot; &quot;Ariz&quot; &quot;Arka&quot; &quot;Cali&quot; &quot;Colo&quot; &quot;Conn&quot; &quot;Dela&quot; &quot;Flor&quot; &quot;Geor&quot; #&gt; [11] &quot;Hawa&quot; &quot;Idah&quot; &quot;Illi&quot; &quot;Indi&quot; &quot;Iowa&quot; &quot;Kans&quot; &quot;Kent&quot; &quot;Loui&quot; &quot;Main&quot; &quot;Mary&quot; #&gt; [21] &quot;Mass&quot; &quot;Mich&quot; &quot;Minn&quot; &quot;Miss&quot; &quot;Miss&quot; &quot;Mont&quot; &quot;Nebr&quot; &quot;Neva&quot; &quot;New &quot; &quot;New &quot; #&gt; [31] &quot;New &quot; &quot;New &quot; &quot;Nort&quot; &quot;Nort&quot; &quot;Ohio&quot; &quot;Okla&quot; &quot;Oreg&quot; &quot;Penn&quot; &quot;Rhod&quot; &quot;Sout&quot; #&gt; [41] &quot;Sout&quot; &quot;Tenn&quot; &quot;Texa&quot; &quot;Utah&quot; &quot;Verm&quot; &quot;Virg&quot; &quot;Wash&quot; &quot;West&quot; &quot;Wisc&quot; &quot;Wyom&quot; This may not be the best solution. Note that there are four states with the same abbreviation \"New \" (New Hampshire, New Jersey, New Mexico, New York). Likewise, North Carolina and North Dakota share the same name \"Nort\". In turn, South Carolina and South Dakota got the same abbreviation \"Sout\". A better way to abbreviate the names of the states can be performed by using the function abbreviate() like so: # abbreviate state names states2 &lt;- abbreviate(states) # remove vector names (for convenience) names(states2) &lt;- NULL states2 #&gt; [1] &quot;Albm&quot; &quot;Alsk&quot; &quot;Arzn&quot; &quot;Arkn&quot; &quot;Clfr&quot; &quot;Clrd&quot; &quot;Cnnc&quot; &quot;Dlwr&quot; &quot;Flrd&quot; &quot;Gerg&quot; #&gt; [11] &quot;Hawa&quot; &quot;Idah&quot; &quot;Illn&quot; &quot;Indn&quot; &quot;Iowa&quot; &quot;Knss&quot; &quot;Kntc&quot; &quot;Losn&quot; &quot;Main&quot; &quot;Mryl&quot; #&gt; [21] &quot;Mssc&quot; &quot;Mchg&quot; &quot;Mnns&quot; &quot;Msss&quot; &quot;Mssr&quot; &quot;Mntn&quot; &quot;Nbrs&quot; &quot;Nevd&quot; &quot;NwHm&quot; &quot;NwJr&quot; #&gt; [31] &quot;NwMx&quot; &quot;NwYr&quot; &quot;NrtC&quot; &quot;NrtD&quot; &quot;Ohio&quot; &quot;Oklh&quot; &quot;Orgn&quot; &quot;Pnns&quot; &quot;RhdI&quot; &quot;SthC&quot; #&gt; [41] &quot;SthD&quot; &quot;Tnns&quot; &quot;Texs&quot; &quot;Utah&quot; &quot;Vrmn&quot; &quot;Vrgn&quot; &quot;Wshn&quot; &quot;WstV&quot; &quot;Wscn&quot; &quot;Wymn&quot; If we decide to try an abbreviation with five letters we just simply change the argument minlength = 5 # abbreviate state names with 5 letters abbreviate(states, minlength = 5) #&gt; Alabama Alaska Arizona Arkansas California #&gt; &quot;Alabm&quot; &quot;Alask&quot; &quot;Arizn&quot; &quot;Arkns&quot; &quot;Clfrn&quot; #&gt; Colorado Connecticut Delaware Florida Georgia #&gt; &quot;Colrd&quot; &quot;Cnnct&quot; &quot;Delwr&quot; &quot;Flord&quot; &quot;Georg&quot; #&gt; Hawaii Idaho Illinois Indiana Iowa #&gt; &quot;Hawai&quot; &quot;Idaho&quot; &quot;Illns&quot; &quot;Indin&quot; &quot;Iowa&quot; #&gt; Kansas Kentucky Louisiana Maine Maryland #&gt; &quot;Kanss&quot; &quot;Kntck&quot; &quot;Lousn&quot; &quot;Maine&quot; &quot;Mryln&quot; #&gt; Massachusetts Michigan Minnesota Mississippi Missouri #&gt; &quot;Mssch&quot; &quot;Mchgn&quot; &quot;Mnnst&quot; &quot;Mssss&quot; &quot;Missr&quot; #&gt; Montana Nebraska Nevada New Hampshire New Jersey #&gt; &quot;Montn&quot; &quot;Nbrsk&quot; &quot;Nevad&quot; &quot;NwHmp&quot; &quot;NwJrs&quot; #&gt; New Mexico New York North Carolina North Dakota Ohio #&gt; &quot;NwMxc&quot; &quot;NwYrk&quot; &quot;NrthC&quot; &quot;NrthD&quot; &quot;Ohio&quot; #&gt; Oklahoma Oregon Pennsylvania Rhode Island South Carolina #&gt; &quot;Oklhm&quot; &quot;Oregn&quot; &quot;Pnnsy&quot; &quot;RhdIs&quot; &quot;SthCr&quot; #&gt; South Dakota Tennessee Texas Utah Vermont #&gt; &quot;SthDk&quot; &quot;Tnnss&quot; &quot;Texas&quot; &quot;Utah&quot; &quot;Vrmnt&quot; #&gt; Virginia Washington West Virginia Wisconsin Wyoming #&gt; &quot;Virgn&quot; &quot;Wshng&quot; &quot;WstVr&quot; &quot;Wscns&quot; &quot;Wymng&quot; 1.1.2 Getting the longest name Now let’s imagine that we need to find the longest name. This implies that we need to count the number of letters in each name. The function nchar() comes handy for that purpose. Here’s how we could do it: # size (in characters) of each name state_chars = nchar(states) state_chars #&gt; [1] 7 6 7 8 10 8 11 8 7 7 6 5 8 7 4 6 8 9 5 8 13 8 9 11 8 #&gt; [26] 7 8 6 13 10 10 8 14 12 4 8 6 12 12 14 12 9 5 4 7 8 10 13 9 7 # longest name states[which(state_chars == max(state_chars))] #&gt; [1] &quot;North Carolina&quot; &quot;South Carolina&quot; 1.1.3 Selecting States To make things more interesting, let’s assume that we wish to select those states containing the letter \"k\". How can we do that? Very simple, we just need to use the function grep() for working with regular expressions. Simply indicate the pattern = \"k\" as follows: # get states names with &#39;k&#39; grep(pattern = &quot;k&quot;, x = states, value = TRUE) #&gt; [1] &quot;Alaska&quot; &quot;Arkansas&quot; &quot;Kentucky&quot; &quot;Nebraska&quot; &quot;New York&quot; #&gt; [6] &quot;North Dakota&quot; &quot;Oklahoma&quot; &quot;South Dakota&quot; Instead of grabbing those names containing \"k\", say we wish to select those states containing the letter \"w\". Again, this can be done with grep(): # get states names with &#39;w&#39; grep(pattern = &quot;w&quot;, x = states, value = TRUE) #&gt; [1] &quot;Delaware&quot; &quot;Hawaii&quot; &quot;Iowa&quot; &quot;New Hampshire&quot; #&gt; [5] &quot;New Jersey&quot; &quot;New Mexico&quot; &quot;New York&quot; Notice that we only selected those states with lowercase \"w\". But what about those states with uppercase \"W\"? There are several options to find a solution for this question. One option is to specify the searched pattern as a character class \"[wW]\": # get states names with &#39;w&#39; or &#39;W&#39; grep(pattern = &quot;[wW]&quot;, x = states, value = TRUE) #&gt; [1] &quot;Delaware&quot; &quot;Hawaii&quot; &quot;Iowa&quot; &quot;New Hampshire&quot; #&gt; [5] &quot;New Jersey&quot; &quot;New Mexico&quot; &quot;New York&quot; &quot;Washington&quot; #&gt; [9] &quot;West Virginia&quot; &quot;Wisconsin&quot; &quot;Wyoming&quot; Another solution is to first convert the state names to lower case, and then look for the character \"w\", like so: # get states names with &#39;w&#39; grep(pattern = &quot;w&quot;, x = tolower(states), value = TRUE) #&gt; [1] &quot;delaware&quot; &quot;hawaii&quot; &quot;iowa&quot; &quot;new hampshire&quot; #&gt; [5] &quot;new jersey&quot; &quot;new mexico&quot; &quot;new york&quot; &quot;washington&quot; #&gt; [9] &quot;west virginia&quot; &quot;wisconsin&quot; &quot;wyoming&quot; Alternatively, instead of converting the state names to lower case we could do the opposite (convert to upper case), and then look for the character \"W\", like so: # get states names with &#39;W&#39; grep(pattern = &quot;W&quot;, x = toupper(states), value = TRUE) #&gt; [1] &quot;DELAWARE&quot; &quot;HAWAII&quot; &quot;IOWA&quot; &quot;NEW HAMPSHIRE&quot; #&gt; [5] &quot;NEW JERSEY&quot; &quot;NEW MEXICO&quot; &quot;NEW YORK&quot; &quot;WASHINGTON&quot; #&gt; [9] &quot;WEST VIRGINIA&quot; &quot;WISCONSIN&quot; &quot;WYOMING&quot; A third solution involves specifying the argument ignore.case=TRUE inside grep(): # get states names with &#39;w&#39; grep(pattern = &quot;w&quot;, x = states, value = TRUE, ignore.case = TRUE) #&gt; [1] &quot;Delaware&quot; &quot;Hawaii&quot; &quot;Iowa&quot; &quot;New Hampshire&quot; #&gt; [5] &quot;New Jersey&quot; &quot;New Mexico&quot; &quot;New York&quot; &quot;Washington&quot; #&gt; [9] &quot;West Virginia&quot; &quot;Wisconsin&quot; &quot;Wyoming&quot; 1.1.4 Some computations Besides manipulating strings and performing pattern matching operations, we can also do some computations. For instance, we could ask for the distribution of the State names’ length. To find the answer we can use nchar(). Furthermore, we can plot a histogram of such distribution: summary(nchar(states)) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 4.00 7.00 8.00 8.44 10.00 14.00 # histogram hist(nchar(states), las = 1, col = &quot;gray80&quot;, main = &quot;Histogram&quot;, xlab = &quot;number of characters in US State names&quot;) Let’s ask a more interesting question. What is the distribution of the vowels in the names of the States? For instance, let’s start with the number of a’s in each name. There’s a very useful function for this purpose: regexpr(). We can use regexpr() to get the number of times that a searched pattern is found in a character vector. When there is no match, we get a value -1. # position of a&#39;s positions_a &lt;- gregexpr(pattern=&quot;a&quot;, text=states, ignore.case = TRUE) # how many a&#39;s? num_a &lt;- sapply(positions_a, function(x) ifelse(x[1]&gt;0, length(x), 0)) num_a #&gt; [1] 4 3 2 3 2 1 0 2 1 1 2 1 0 2 1 2 0 2 1 2 2 1 1 0 0 2 2 2 1 0 0 0 2 2 0 2 0 2 #&gt; [39] 1 2 2 0 1 1 0 1 1 1 0 0 If you inspect positions_a you’ll see that it contains some negative numbers -1. This means there are no letters a in that name. To get the number of occurrences of a’s we are taking a shortcut with sapply(). The same operation can be performed by using the function str_count() from the package \"stringr\". # load stringr (remember to install it first) library(stringr) # total number of a&#39;s str_count(states, &quot;a&quot;) #&gt; [1] 3 2 1 2 2 1 0 2 1 1 2 1 0 2 1 2 0 2 1 2 2 1 1 0 0 2 2 2 1 0 0 0 2 2 0 2 0 2 #&gt; [39] 1 2 2 0 1 1 0 1 1 1 0 0 Notice that we are only getting the number of a’s in lower case. Since str_count() does not contain the argument ignore.case, we need to transform all letters to lower case, and then count the number of a’s like this: # total number of a&#39;s str_count(tolower(states), &quot;a&quot;) #&gt; [1] 4 3 2 3 2 1 0 2 1 1 2 1 0 2 1 2 0 2 1 2 2 1 1 0 0 2 2 2 1 0 0 0 2 2 0 2 0 2 #&gt; [39] 1 2 2 0 1 1 0 1 1 1 0 0 Once we know how to do it for one vowel, we can do the same for all the vowels: # calculate number of vowels in each name vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;) num_vowels &lt;- vector(mode = &quot;integer&quot;, length = 5) for (j in seq_along(vowels)) { num_aux &lt;- str_count(tolower(states), vowels[j]) num_vowels[j] &lt;- sum(num_aux) } # sort them in decreasing order names(num_vowels) &lt;- vowels sort(num_vowels, decreasing = TRUE) #&gt; a i o e u #&gt; 61 44 36 28 8 # barplot barplot(num_vowels, main = &quot;Number of vowels in USA States names&quot;, border = NA, xlim = c(0, 80), las = 1, horiz = TRUE) "],
["chars.html", "2 Character Strings in R 2.1 Introduction 2.2 Characters in R 2.3 Getting Started with Strings 2.4 Creating Character Strings 2.5 Strings and R Objects 2.6 The Workhorse Function paste() 2.7 Getting Text into R", " 2 Character Strings in R 2.1 Introduction This chapter introduces you to the basic concepts for creating character vectors and character strings in R. You will also learn how R treats objects containing characters. 2.2 Characters in R In R, a piece of text is represented as a sequence of characters (letters, numbers, and symbols). The data type R provides for storing sequences of characters is character. Formally, the mode of an object that holds character strings in R is \"character\". You express character strings by surrounding text within double quotes: &quot;a character string using double quotes&quot; or you can also surround text within single quotes: &#39;a character string using single quotes&#39; The important thing is that you must match the type of quotes that your are using. A starting double quote must have an ending double quote. Likewise, a string with an opening single quote must be closed with a single quote. Typing characters in R like in above examples is not very useful. Typically, you are going to create objects or variables containing some strings. For example, you can create a variable string that stores some string: string &lt;- &#39;do more with less&#39; string #&gt; [1] &quot;do more with less&quot; Notice that when you print a character object, R displays it using double quotes (regardless of whether the string was created using single or double quotes). This allows you to quickly identify when an object contains character values. When writing strings, you can insert single quotes in a string with double quotes, and vice versa: # single quotes within double quotes ex1 &lt;- &quot;The &#39;R&#39; project for statistical computing&quot; # double quotes within single quotes ex2 &lt;- &#39;The &quot;R&quot; project for statistical computing&#39; However, you cannot directly insert single quotes in a string with single quotes, neither you can insert double quotes in a string with double quotes (Don’t do this!): ex3 &lt;- &quot;This &quot;is&quot; totally unacceptable&quot; ex4 &lt;- &#39;This &#39;is&#39; absolutely wrong&#39; In both cases R will give you an error due to the unexpected presence of either a double quote within double quotes, or a single quote within single quotes. If you really want to include a double quote as part of the string, you need to escape the double quote using a backslash \\ before it: &quot;The \\&quot;R\\&quot; project for statistical computing&quot; We will talk more about escaping characters in the following chapters. 2.3 Getting Started with Strings Perhaps the most common use of character strings in R has to do with: names of files and directories names of elements in data objects text elements displayed in plots and graphs When you read a file, for instance a data table stored in a csv file, you typically use the read.table() function and friends—e.g. read.csv(), read.delim(). Assuming that the file dataset.csv is in your working directory: dat &lt;- read.csv(file = &#39;dataset.csv&#39;) The main parameter for the function read.csv() is file which requires a character string with the pathname of the file. Another example of a basic use of characters is when you assign names to the elements of some data structure in R. For instance, if you want to name the elements of a (numeric) vector, you can use the function names() as follows: num_vec &lt;- 1:5 names(num_vec) &lt;- c(&#39;uno&#39;, &#39;dos&#39;, &#39;tres&#39;, &#39;cuatro&#39;, &#39;cinco&#39;) num_vec Likewise, many of the parameters in the plotting functions require some sort of input string. Below is a hypothetical example of a scatterplot that includes several graphical elements like the main title (main), subtitle (sub), labels for both x-axis and y-axis (xlab, ylab), the name of the color (col), and the symbol for the point character (pch). plot(x, y, main = &#39;Main Title&#39;, sub = &#39;Subtitle&#39;, xlab = &#39;x-axis label&#39;, ylab = &#39;y-axis label&#39;, col = &#39;red&#39;, pch = &#39;x&#39;) 2.4 Creating Character Strings Besides the single quotes '' or double quotes \"\", R provides the function character() to create character vectors. More specifically, character() is the function that creates vector objects of type \"character\". When using character() you just have to specify the length of the vector. The output will be a character vector filled of empty strings: # character vector with 5 empty strings char_vector &lt;- character(5) char_vector #&gt; [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; When would you use character()? A typical usage case is when you want to initialize an empty character vector of a given length. The idea is to create an object that you will modify later with some computation. As with any other vector, once an empty character vector has been created, you can add new components to it by simply giving it an index value outside its previous range: # another example example &lt;- character(0) example #&gt; character(0) # check its length length(example) #&gt; [1] 0 # add first element example[1] &lt;- &quot;first&quot; example #&gt; [1] &quot;first&quot; # check its length again length(example) #&gt; [1] 1 You can add more elements without the need to follow a consecutive index range: example[4] &lt;- &quot;fourth&quot; example #&gt; [1] &quot;first&quot; NA NA &quot;fourth&quot; length(example) #&gt; [1] 4 Notice that the vector example went from containing one-element to contain four-elements without specifying the second and third elements. R fills this gap with missing values NA. 2.4.1 Empty string The most basic type of string is the empty string produced by consecutive quotation marks: \"\". Technically, \"\" is a string with no characters in it, hence the name “empty string”: # empty string empty_str &lt;- &quot;&quot; empty_str #&gt; [1] &quot;&quot; # class class(empty_str) #&gt; [1] &quot;character&quot; 2.4.2 Empty character vector Another basic string structure is the empty character vector produced by the function character() and its argument length=0: # empty character vector empty_chr &lt;- character(0) empty_chr #&gt; character(0) # class class(empty_chr) #&gt; [1] &quot;character&quot; It is important not to confuse the empty character vector character(0) with the empty string \"\"; one of the main differences between them is that they have different lengths: # length of empty string length(empty_str) #&gt; [1] 1 # length of empty character vector length(empty_chr) #&gt; [1] 0 Notice that the empty string empty_str has length 1, while the empty character vector empty_chr has length 0. Also, character(0) occurs when you have a character vector with one or more elements, and you attempt to subset the position 0: string &lt;- c(&#39;sun&#39;, &#39;sky&#39;, &#39;clouds&#39;) string #&gt; [1] &quot;sun&quot; &quot;sky&quot; &quot;clouds&quot; If you try to retrieve the element in position 0 you get: string[0] #&gt; character(0) 2.4.3 Function c() There is also the generic function c() (concatenate or combine) that you can use to create character vectors. Simply pass any number of character elements separated by commas: string &lt;- c(&#39;sun&#39;, &#39;sky&#39;, &#39;clouds&#39;) string #&gt; [1] &quot;sun&quot; &quot;sky&quot; &quot;clouds&quot; Again, notice that you can use single or double quotes to define the character elements inside c() planets &lt;- c(&quot;mercury&quot;, &#39;venus&#39;, &quot;mars&quot;) planets #&gt; [1] &quot;mercury&quot; &quot;venus&quot; &quot;mars&quot; 2.4.4 is.character() and as.character() Related to character() R provides two related functions: as.character() and is.character(). These two functions are methods for coercing objects to type \"character\", and testing whether an R object is of type \"character\". For instance, let’s define two objects a and b as follows: # define two objects &#39;a&#39; and &#39;b&#39; a &lt;- &quot;test me&quot; b &lt;- 8 + 9 To test if a and b are of type \"character\" use the function is.character(): # are &#39;a&#39; and &#39;b&#39; characters? is.character(a) #&gt; [1] TRUE is.character(b) #&gt; [1] FALSE Likewise, you can also use the function class() to get the class of an object: # classes of &#39;a&#39; and &#39;b&#39; class(a) #&gt; [1] &quot;character&quot; class(b) #&gt; [1] &quot;numeric&quot; The function as.character() is a coercing method. For better or worse, R allows you to convert (i.e. coerce) non-character objects into character strings with the function as.character(): # converting &#39;b&#39; as character b &lt;- as.character(b) b #&gt; [1] &quot;17&quot; 2.5 Strings and R Objects Before continuing our discussion on functions for manipulating strings, we need to talk about some important technicalities. R has five main types of objects to store data: vector, factor, matrix (and array), data.frame, and list. We can use each of those objects to store character strings. However, these objects will behave differently depending on whether we store character data with other types of data. Let’s see how R treats objects with different types of data (e.g. character, numeric, logical). 2.5.1 Behavior of R objects with character strings Vectors. The most basic type of data container are vectors. You can think of vectors as the building blocks for other more complex data structures. R has six types of vectors, technically referred to as atomic types or atomic vectors: logical, integer, double, character, complex, and raw. Type Description logical a vector containing logical values integer a vector containing integer values double a vector containing real values character a vector containing character values complex a vector containing complex values raw a vector containing bytes Vectors are atomic structures because their values must be all of the same type. This means that any given vector must be unambiguously either logical, numeric, complex, character or raw. So what happens when you mix different types of data in a vector? # vector with numbers and characters c(1:5, pi, &quot;text&quot;) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; #&gt; [5] &quot;5&quot; &quot;3.14159265358979&quot; &quot;text&quot; As you can tell, the resulting vector from combining integers 1:5, the number pi, and some \"text\" is a vector with all its elements treated as character strings. In other words, when you combine mixed data in vectors, strings will dominate. This means that the mode of the vector will be \"character\", even if you mix logical values: # vector with numbers, logicals, and characters c(1:5, TRUE, pi, &quot;text&quot;, FALSE) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; #&gt; [5] &quot;5&quot; &quot;TRUE&quot; &quot;3.14159265358979&quot; &quot;text&quot; #&gt; [9] &quot;FALSE&quot; In fact, R follows two basic rules of data types coercion. The most strict rule is: if a character string is present in a vector, everything else in the vector will be converted to character strings. The other coercing rule is: if a vector only has logicals and numbers, then logicals will be converted to numbers; TRUE values become 1, and FALSE values become 0. Keeping these rules in mind will save you from many headaches and frustrating moments. Moreover, you can use them in your favor to manipulate data in very useful ways. Matrices. The same behavior of vectors happens when you mix characters and numbers in matrices. Again, everything will be treated as characters: # matrix with numbers and characters rbind(1:5, letters[1:5]) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; #&gt; [2,] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; Data frames. With data frames, things are a bit different. By default, character strings inside a data frame will be converted to factors: # data frame with numbers and characters df1 = data.frame(numbers=1:5, letters=letters[1:5]) df1 #&gt; numbers letters #&gt; 1 1 a #&gt; 2 2 b #&gt; 3 3 c #&gt; 4 4 d #&gt; 5 5 e # examine the data frame structure str(df1) #&gt; &#39;data.frame&#39;: 5 obs. of 2 variables: #&gt; $ numbers: int 1 2 3 4 5 #&gt; $ letters: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5 To turn-off the data.frame()’s default behavior of converting strings into factors, use the argument stringsAsFactors = FALSE: # data frame with numbers and characters df2 &lt;- data.frame( numbers = 1:5, letters = letters[1:5], stringsAsFactors = FALSE) df2 #&gt; numbers letters #&gt; 1 1 a #&gt; 2 2 b #&gt; 3 3 c #&gt; 4 4 d #&gt; 5 5 e # examine the data frame structure str(df2) #&gt; &#39;data.frame&#39;: 5 obs. of 2 variables: #&gt; $ numbers: int 1 2 3 4 5 #&gt; $ letters: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... Even though df1 and df2 are identically displayed, their structure is different. While df1$letters is stored as a \"factor\", df2$letters is stored as a \"character\". Lists. With lists, you can combine any type of data objects. The type of data in each element of the list will maintain its corresponding mode: # list with elements of different mode list(1:5, letters[1:5], rnorm(5)) #&gt; [[1]] #&gt; [1] 1 2 3 4 5 #&gt; #&gt; [[2]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; #&gt; #&gt; [[3]] #&gt; [1] -0.507 0.192 -1.172 -2.088 -2.106 2.6 The Workhorse Function paste() The function paste() is perhaps one of the most important functions that you can use to create and build strings. paste() takes one or more R objects, converts them to \"character\", and then it concatenates (pastes) them to form one or several character strings. Its usage has the following form: paste(..., sep = &quot; &quot;, collapse = NULL) The argument ... means that it takes any number of objects. The argument sep is a character string that is used as a separator. The argument collapse is an optional string to indicate if you want all the terms to be collapsed into a single string. Here is a simple example with paste(): # paste PI &lt;- paste(&quot;The life of&quot;, pi) PI #&gt; [1] &quot;The life of 3.14159265358979&quot; As you can see, the default separator is a blank space (sep = \" \"). But you can select another character, for example sep = \"-\": # paste IloveR &lt;- paste(&quot;I&quot;, &quot;love&quot;, &quot;R&quot;, sep = &quot;-&quot;) IloveR #&gt; [1] &quot;I-love-R&quot; If you give paste() objects of different length, then it will apply a recycling rule. For example, if you paste a single character \"X\" with the sequence 1:5, and separator sep = \".\", this is what you get: # paste with objects of different lengths paste(&quot;X&quot;, 1:5, sep = &quot;.&quot;) #&gt; [1] &quot;X.1&quot; &quot;X.2&quot; &quot;X.3&quot; &quot;X.4&quot; &quot;X.5&quot; To see the effect of the collapse argument, let’s compare the difference with collapsing and without it: # paste with collapsing paste(1:3, c(&quot;!&quot;,&quot;?&quot;,&quot;+&quot;), sep = &#39;&#39;, collapse = &quot;&quot;) #&gt; [1] &quot;1!2?3+&quot; # paste without collapsing paste(1:3, c(&quot;!&quot;,&quot;?&quot;,&quot;+&quot;), sep = &#39;&#39;) #&gt; [1] &quot;1!&quot; &quot;2?&quot; &quot;3+&quot; One of the potential problems with paste() is that it coerces missing values NA into the character \"NA\": # with missing values NA evalue &lt;- paste(&quot;the value of &#39;e&#39; is&quot;, exp(1), NA) evalue #&gt; [1] &quot;the value of &#39;e&#39; is 2.71828182845905 NA&quot; In addition to paste(), there’s also the function paste0() which is the equivalent of paste(..., sep = &quot;&quot;, collapse) # collapsing with paste0 paste0(&quot;let&#39;s&quot;, &quot;collapse&quot;, &quot;all&quot;, &quot;these&quot;, &quot;words&quot;) #&gt; [1] &quot;let&#39;scollapseallthesewords&quot; 2.7 Getting Text into R We’ve seen how to express character strings using single quotes '' or double quotes \"\". But we also need to discuss how to get text into R, that is, how to import and read files that contain character strings. So, how do we get text into R? Well, it basically depends on the type-format of the files we want to read. We will describe two general situations. One in which the content of the file can be represented in tabular format (i.e. rows and columns). The other one when the content does not have a tabular structure. In this second case, we have characters that are in an unstructured form (i.e. just lines of strings) or at least in a non-tabular format such as html, xml, or other markup language format. Another function is scan() which allows us to read data in several formats. Usually we use scan() to parse R scripts, but we can also use to import text (characters) 2.7.1 Reading tables If the data we want to import is in some tabular format (i.e. cells and columns) we can use the set of functions to read tables like read.table() and its sister functions, e.g. read.csv(), read.delim(), read.fwf(). These functions read a file in table format and create a data frame from it, with rows corresponding to cases, and columns corresponding to fields in the file. Function Description read.table() main function to read file in table format read.csv() reads csv files separated by a comma \",\" read.csv2() reads csv files separated by a semicolon \";\" read.delim() reads files separated by tabs \"\\t\" read.delim2() similar to read.delim() read.fwf() read fixed width format files A word of caution about the built-in functions to read data tables: by default they all convert characters into R factors. This means that if there is a column with characters, R will treat this data as qualitative variable. To turn off this behavior, we need to specify the argument stringsAsFactors = FALSE. In this way, all the characters in the imported file will be kept as characters once we read them in R. Let’s see a simple example reading a file from the Australian radio broadcaster ABC (http://www.abc.net.au/radio/). In particular, we’ll read a csv file that contains data from ABC’s radio stations. Such file is located at: http://www.abc.net.au/local/data/public/stations/abc-local-radio.csv To import the file abc-local-radio.csv, we can use either read.table() or read.csv() (just choose the right parameters). Here’s the code to read the file with read.table(): # assembling url abc &lt;- &quot;http://www.abc.net.au/&quot; radios &lt;- &quot;local/data/public/stations/abc-local-radio.csv&quot; abc_radiosl &lt;- paste0(abc, radios) # read data from URL radio &lt;- read.table( file = abc_radios, header = TRUE, sep = &#39;,&#39;, stringsAsFactors = FALSE) In this case, the location of the file is defined in the object abc which is the first argument passed to read.table(). Then we choose other arguments such as header = TRUE, sep = \",\", and stringsAsFactors = FALSE. The argument header = TRUE indicates that the first row of the file contains the names of the columns. The separator (a comma) is specifcied by sep = \",\". And finally, to keep the character strings in the file as \"character\" in the data frame, we use stringsAsFactors = FALSE. If everything went fine during the file reading operation, the next thing to do is to chek the size of the created data frame using dim(): # size of table in &#39;radio&#39; dim(radio) #&gt; [1] 53 18 Notice that the data frame radio is a table with 53 rows and 18 columns. If we examine ths structure with str() we will get information of each column. The argument vec.len = 1 indicates that we just want the first element of each variable to be displayed: # structure of columns str(radio, vec.len = 1) #&gt; &#39;data.frame&#39;: 53 obs. of 18 variables: #&gt; $ State : chr &quot;QLD&quot; ... #&gt; $ Website.URL : chr &quot;http://www.abc.net.au/brisbane/&quot; ... #&gt; $ Station : chr &quot;ABC Radio Brisbane&quot; ... #&gt; $ Town : chr &quot; Brisbane &quot; ... #&gt; $ Latitude : num -27.5 ... #&gt; $ Longitude : num 153 ... #&gt; $ Talkback.number : chr &quot;1300 222 612&quot; ... #&gt; $ Enquiries.number: chr &quot;07 3377 5222&quot; ... #&gt; $ Fax.number : chr &quot;07 3377 5612&quot; ... #&gt; $ Sms.number : chr &quot;0467 922 612&quot; ... #&gt; $ Street.number : chr &quot;114 Grey Street&quot; ... #&gt; $ Street.suburb : chr &quot;South Brisbane&quot; ... #&gt; $ Street.postcode : int 4101 4700 ... #&gt; $ PO.box : chr &quot;GPO Box 9994&quot; ... #&gt; $ PO.suburb : chr &quot;Brisbane&quot; ... #&gt; $ PO.postcode : int 4001 4700 ... #&gt; $ Twitter : chr &quot; abcbrisbane&quot; ... #&gt; $ Facebook : chr &quot; https://www.facebook.com/abcinbrisbane&quot; ... As you can tell, most of the 18 variables are in \"character\" mode. Only $Latitude, $Longitude, $Street.postcode and $PO.postcode have a different mode. 2.7.2 Reading raw text If what we want is to import text as is (i.e. we want to read raw text) then we need to use the function readLines(). This function is the one we should use if we don’t want R to assume that the data is in any particular form. The way we work with readLines() is by passing it the name of a file or the name of a URL that we want to read. The output is a character vector with one element for each line of the file or url. The produced vector will contain as many elements as lines in the read file. Let’s see how to read a text file. For this example we will use a text file from the site TEXTFILES.COM (by Jason Scott) http://www.textfiles.com/music/ . This site contains a section of music related text files. For demonstration purposes let’s consider the “Top 105.3 songs of 1991” according to the “Modern Rock” radio station KITS San Francisco. The corresponding txt file is located at: http://www.textfiles.com/music/ktop100.txt. # read &#39;ktop100.txt&#39; file top105 &lt;- readLines(&quot;http://www.textfiles.com/music/ktop100.txt&quot;) readLines() creates a character vector in which each element represents the lines of the URL we are trying to read. To know how many elements (i.e how many lines) are in top105 we can use the function length(). To inspect the first elements (i.e. first lines of the text file) use head() # how many lines length(top105) #&gt; [1] 123 # inspecting first elements head(top105) #&gt; [1] &quot;From: ed@wente.llnl.gov (Ed Suranyi)&quot; #&gt; [2] &quot;Date: 12 Jan 92 21:23:55 GMT&quot; #&gt; [3] &quot;Newsgroups: rec.music.misc&quot; #&gt; [4] &quot;Subject: KITS&#39; year end countdown&quot; #&gt; [5] &quot;&quot; #&gt; [6] &quot;&quot; Looking at the output provided by head() the first four lines contain some information about the subject of the email (KITS’ year end countdown). The fifth and sixth lines are empty lines. If we inspect the next few lines, we’ll see that the list of songs in the top100 starts at line number 11. # top 5 songs top105[11:15] #&gt; [1] &quot;1. NIRVANA SMELLS LIKE TEEN SPIRIT&quot; #&gt; [2] &quot;2. EMF UNBELIEVABLE&quot; #&gt; [3] &quot;3. R.E.M. LOSING MY RELIGION&quot; #&gt; [4] &quot;4. SIOUXSIE &amp; THE BANSHEES KISS THEM FOR ME&quot; #&gt; [5] &quot;5. B.A.D. II RUSH&quot; Each line has the ranking number, followed by a dot, followed by a blank space, then the name of the artist/group, followed by a bunch of white spaces, and then the title of the song. As you can see, the number one hit of 1991 was “Smells like teen spirit” by Nirvana. What about the last songs in KITS’ ranking? In order to get the answer we can use the tail() function to inspect the last n = 10 elements of the file: # inspecting last 10 elements tail(top105, n = 10) #&gt; [1] &quot;101. SMASHING PUMPKINS SIVA&quot; #&gt; [2] &quot;102. ELVIS COSTELLO OTHER SIDE OF ...&quot; #&gt; [3] &quot;103. SEERS PSYCHE OUT&quot; #&gt; [4] &quot;104. THRILL KILL CULT SEX ON WHEELZ&quot; #&gt; [5] &quot;105. MATTHEW SWEET I&#39;VE BEEN WAITING&quot; #&gt; [6] &quot;105.3 LATOUR PEOPLE ARE STILL HAVING SEX&quot; #&gt; [7] &quot;&quot; #&gt; [8] &quot;Ed&quot; #&gt; [9] &quot;ed@wente.llnl.gov&quot; #&gt; [10] &quot;&quot; Note that the last four lines don’t contain information about the songs. Moreover, the number of songs does not stop at 105. In fact the ranking goes till 106 songs (last number being 105.3) We’ll stop here the discussion of this chapter. However, it is importat to keep in mind that text files come in a great variety of forms, shapes, sizes, and flavors. For more information on how to import files in R, the authoritative document is the guide on R Data Import/Export (by the R Core Team) available at: http://cran.r-project.org/doc/manuals/r-release/R-data.html "],
["basics1.html", "3 Basic Manipulations with \"base\" Functions 3.1 Introduction 3.2 Basic String Manipulations 3.3 Set Operations", " 3 Basic Manipulations with \"base\" Functions 3.1 Introduction In this chapter you will learn about the different functions to do what I call basic manipulations. By “basic” I mean transforming and processing strings in such way that do not require the use of regular expressions. More advanced manipulations involve defining patterns of text and matching such patterns. This is the essential idea behind regular expressions, which is the content of part 3 in this book. 3.2 Basic String Manipulations Besides creating and printing strings, there are a number of very handy functions in R for doing some basic manipulation of strings. In this section we will review the following functions: Function Description nchar() number of characters tolower() convert to lower case toupper() convert to upper case casefold() case folding chartr() character translation abbreviate() abbreviation substring() substrings of a character vector substr() substrings of a character vector 3.2.1 Count number of characters with nchar() One of the main functions for manipulating character strings is nchar() which counts the number of characters in a string. In other words, nchar() provides the length of a string: # how many characters? nchar(c(&quot;How&quot;, &quot;many&quot;, &quot;characters?&quot;)) #&gt; [1] 3 4 11 # how many characters? nchar(&quot;How many characters?&quot;) #&gt; [1] 20 Notice that the white spaces between words in the second example are also counted as characters. It is important not to confuse nchar() with length(). While the former gives us the number of characters, the later only gives the number of elements in a vector. # how many elements? length(c(&quot;How&quot;, &quot;many&quot;, &quot;characters?&quot;)) #&gt; [1] 3 # how many elements? length(&quot;How many characters?&quot;) #&gt; [1] 1 3.2.2 Convert to lower case with tolower() R comes with three functions for text casefolding. tolower() toupper() casefold() The first function we’ll discuss is tolower() which converts any upper case characters into lower case: # to lower case tolower(c(&quot;aLL ChaRacterS in LoweR caSe&quot;, &quot;ABCDE&quot;)) #&gt; [1] &quot;all characters in lower case&quot; &quot;abcde&quot; 3.2.3 Convert to upper case with toupper() The opposite function of tolower() is toupper. As you may guess, this function converts any lower case characters into upper case: # to upper case toupper(c(&quot;All ChaRacterS in Upper Case&quot;, &quot;abcde&quot;)) #&gt; [1] &quot;ALL CHARACTERS IN UPPER CASE&quot; &quot;ABCDE&quot; 3.2.4 Upper or lower case conversion with casefold() The third function for case-folding is casefold() which is a wrapper for both tolower() and toupper(). Its uasge has the following form: casefold(x, upper = FALSE) By default, casefold() converts all characters to lower case, but you can use the argument upper = TRUE to indicate the opposite (characters in upper case): # lower case folding casefold(&quot;aLL ChaRacterS in LoweR caSe&quot;) #&gt; [1] &quot;all characters in lower case&quot; # upper case folding casefold(&quot;All ChaRacterS in Upper Case&quot;, upper = TRUE) #&gt; [1] &quot;ALL CHARACTERS IN UPPER CASE&quot; I’ve found the case-folding functions to be very helpful when I write functions that take a character input which may be specified in lower or upper case, or perhaps as a mix of both cases. For instance, consider the function temp_convert() that takes a temperature value in Fahrenheit degress, and a character string indicating the name of the scale to be converted. temp_convert &lt;- function(deg = 1, to = &quot;celsius&quot;) { switch(to, &quot;celsius&quot; = (deg - 32) * (5/9), &quot;kelvin&quot; = (deg + 459.67) * (5/9), &quot;reaumur&quot; = (deg - 32) * (4/9), &quot;rankine&quot; = deg + 459.67) } Here is how you call temp_convert() to convert 10 Fahrenheit degrees into celsius degrees: temp_convert(deg = 10, to = &quot;celsius&quot;) #&gt; [1] -12.2 temp_convert() works fine when the argument to = 'celsius'. But what happens if you try temp_convert(30, 'Celsius') or temp_convert(30, 'CELSIUS')? To have a more flexible function temp_convert() you can apply tolower() to the argument to, and in this way guarantee that the provided string by the user is always in lower case: temp_convert &lt;- function(deg = 1, to = &quot;celsius&quot;) { switch(tolower(to), &quot;celsius&quot; = (deg - 32) * (5/9), &quot;kelvin&quot; = (deg + 459.67) * (5/9), &quot;reaumur&quot; = (deg - 32) * (4/9), &quot;rankine&quot; = deg + 459.67) } Now all the following three calls are equivalent: temp_convert(30, &#39;celsius&#39;) temp_convert(30, &#39;Celsius&#39;) temp_convert(30, &#39;CELSIUS&#39;) 3.2.5 Character translation with chartr() There’s also the function chartr() which stands for character translation. chartr() takes three arguments: an old string, a new string, and a character vector x: chartr(old, new, x) The way chartr() works is by replacing the characters in old that appear in x by those indicated in new. For example, suppose we want to translate the letter \"a\" (lower case) with \"A\" (upper case) in the sentence \"This is a boring string\": # replace &#39;a&#39; by &#39;A&#39; chartr(&quot;a&quot;, &quot;A&quot;, &quot;This is a boring string&quot;) #&gt; [1] &quot;This is A boring string&quot; It is important to note that old and new must have the same number of characters, otherwise you will get a nasty error message like this one: # incorrect use chartr(&quot;ai&quot;, &quot;X&quot;, &quot;This is a bad example&quot;) #&gt; Error in chartr(&quot;ai&quot;, &quot;X&quot;, &quot;This is a bad example&quot;): &#39;old&#39; is longer than &#39;new&#39; Here’s a more interesting example with old = \"aei\" and new = \"\\#!?\". This implies that any 'a' in 'x' will be replaced by '\\#', any 'e' in 'x' will be replaced by '?', and any 'i' in 'x' will be replaced by '?': # multiple replacements crazy &lt;- c(&quot;Here&#39;s to the crazy ones&quot;, &quot;The misfits&quot;, &quot;The rebels&quot;) chartr(&quot;aei&quot;, &quot;#!?&quot;, crazy) #&gt; [1] &quot;H!r!&#39;s to th! cr#zy on!s&quot; &quot;Th! m?sf?ts&quot; #&gt; [3] &quot;Th! r!b!ls&quot; 3.2.6 Abbreviate strings with abbreviate() Another useful function for basic manipulation of character strings is abbreviate(). Its usage has the following structure: abbreviate(names.org, minlength = 4, dot = FALSE, strict = FALSE, method = c(&quot;left.keep&quot;, &quot;both.sides&quot;)) Although there are several arguments, the main parameter is the character vector (names.org) which will contain the names that we want to abbreviate: # some color names some_colors &lt;- colors()[1:4] some_colors #&gt; [1] &quot;white&quot; &quot;aliceblue&quot; &quot;antiquewhite&quot; &quot;antiquewhite1&quot; # abbreviate (default usage) colors1 &lt;- abbreviate(some_colors) colors1 #&gt; white aliceblue antiquewhite antiquewhite1 #&gt; &quot;whit&quot; &quot;alcb&quot; &quot;antq&quot; &quot;ant1&quot; # abbreviate with &#39;minlength&#39; colors2 &lt;- abbreviate(some_colors, minlength = 5) colors2 #&gt; white aliceblue antiquewhite antiquewhite1 #&gt; &quot;white&quot; &quot;alcbl&quot; &quot;antqw&quot; &quot;antq1&quot; # abbreviate colors3 &lt;- abbreviate(some_colors, minlength = 3, method = &quot;both.sides&quot;) colors3 #&gt; white aliceblue antiquewhite antiquewhite1 #&gt; &quot;wht&quot; &quot;alc&quot; &quot;ant&quot; &quot;an1&quot; A common use for abbreviate() is when plotting names of objects or variables in a graphic. I will use the built-in data set mtcars to show you a simple example with a scatterplot between variables mpg and disp plot(mtcars$mpg, mtcars$disp, type = &quot;n&quot;) text(mtcars$mpg, mtcars$disp, rownames(mtcars)) The names of the cars are all over the plot. In this situation you may want to consider using abbreviate() to shrink the names of the cars and produce a less “crowded” plot: plot(mtcars$mpg, mtcars$disp, type = &quot;n&quot;) text(mtcars$mpg, mtcars$disp, abbreviate(rownames(mtcars))) 3.2.7 Replace substrings with substr() One common operation when working with strings is the extraction and replacement of some characters. There a various ways in which characters can be replaced. If the replacement is based on the positions that characters occupy in the string, you can use the functions substr() and substring() substr() extracts or replaces substrings in a character vector. Its usage has the following form: substr(x, start, stop) x is a character vector, start indicates the first element to be replaced, and stop indicates the last element to be replaced: # extract &#39;bcd&#39; substr(&quot;abcdef&quot;, 2, 4) #&gt; [1] &quot;bcd&quot; # replace 2nd letter with hash symbol x &lt;- c(&quot;may&quot;, &quot;the&quot;, &quot;force&quot;, &quot;be&quot;, &quot;with&quot;, &quot;you&quot;) substr(x, 2, 2) &lt;- &quot;#&quot; x #&gt; [1] &quot;m#y&quot; &quot;t#e&quot; &quot;f#rce&quot; &quot;b#&quot; &quot;w#th&quot; &quot;y#u&quot; # replace 2nd and 3rd letters with happy face y = c(&quot;may&quot;, &quot;the&quot;, &quot;force&quot;, &quot;be&quot;, &quot;with&quot;, &quot;you&quot;) substr(y, 2, 3) &lt;- &quot;:)&quot; y #&gt; [1] &quot;m:)&quot; &quot;t:)&quot; &quot;f:)ce&quot; &quot;b:&quot; &quot;w:)h&quot; &quot;y:)&quot; # replacement with recycling z &lt;- c(&quot;may&quot;, &quot;the&quot;, &quot;force&quot;, &quot;be&quot;, &quot;with&quot;, &quot;you&quot;) substr(z, 2, 3) &lt;- c(&quot;#&quot;, &quot;```&quot;) z #&gt; [1] &quot;m#y&quot; &quot;t``&quot; &quot;f#rce&quot; &quot;b`&quot; &quot;w#th&quot; &quot;y``&quot; 3.2.8 Replace substrings with substring() Closely related to substr() is the function substring() which extracts or replaces substrings in a character vector. Its usage has the following form: substring(text, first, last = 1000000L) text is a character vector, first indicates the first element to be replaced, and last indicates the last element to be replaced: # same as &#39;substr&#39; substring(&quot;ABCDEF&quot;, 2, 4) #&gt; [1] &quot;BCD&quot; substr(&quot;ABCDEF&quot;, 2, 4) #&gt; [1] &quot;BCD&quot; # extract each letter substring(&quot;ABCDEF&quot;, 1:6, 1:6) #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; # multiple replacement with recycling text6 &lt;- c(&quot;more&quot;, &quot;emotions&quot;, &quot;are&quot;, &quot;better&quot;, &quot;than&quot;, &quot;less&quot;) substring(text6, 1:3) &lt;- c(&quot; &quot;, &quot;zzz&quot;) text6 #&gt; [1] &quot; ore&quot; &quot;ezzzions&quot; &quot;ar &quot; &quot;zzzter&quot; &quot;t an&quot; &quot;lezz&quot; 3.3 Set Operations R has dedicated functions for performing set operations on two given vectors. This implies that we can apply functions such as set union, intersection, difference, equality and membership, on \"character\" vectors. Function Description union() set union intersect() intersection setdiff() set difference setequal() equal sets identical() exact equality is.element() is element %in%() contains sort() sorting paste(rep()) repetition 3.3.1 Set union with union() Let’s start our reviewing of set functions with union(). As its name indicates, you can use `union()} when you want to obtain the elements of the union between two character vectors: # two character vectors set1 &lt;- c(&quot;some&quot;, &quot;random&quot;, &quot;words&quot;, &quot;some&quot;) set2 &lt;- c(&quot;some&quot;, &quot;many&quot;, &quot;none&quot;, &quot;few&quot;) # union of set1 and set2 union(set1, set2) #&gt; [1] &quot;some&quot; &quot;random&quot; &quot;words&quot; &quot;many&quot; &quot;none&quot; &quot;few&quot; Notice that union() discards any duplicated values in the provided vectors. In the previous example the word \"some\" appears twice inside set1 but it appears only once in the union. In fact all the set operation functions will discard any duplicated values. 3.3.2 Set intersection with intersect() Set intersection is performed with the function intersect(). You can use this function when you wish to get those elements that are common to both vectors: # two character vectors set3 &lt;- c(&quot;some&quot;, &quot;random&quot;, &quot;few&quot;, &quot;words&quot;) set4 &lt;- c(&quot;some&quot;, &quot;many&quot;, &quot;none&quot;, &quot;few&quot;) # intersect of set3 and set4 intersect(set3, set4) #&gt; [1] &quot;some&quot; &quot;few&quot; 3.3.3 Set difference with setdiff() Related to the intersection, you might be interested in getting the difference of the elements between two character vectors. This can be done with setdiff(): # two character vectors set5 &lt;- c(&quot;some&quot;, &quot;random&quot;, &quot;few&quot;, &quot;words&quot;) set6 &lt;- c(&quot;some&quot;, &quot;many&quot;, &quot;none&quot;, &quot;few&quot;) # difference between set5 and set6 setdiff(set5, set6) #&gt; [1] &quot;random&quot; &quot;words&quot; 3.3.4 Set equality with setequal() The function setequal() allows you to test the equality of two character vectors. If the vectors contain the same elements, setequal() returns TRUE (FALSE otherwise) # three character vectors set7 &lt;- c(&quot;some&quot;, &quot;random&quot;, &quot;strings&quot;) set8 &lt;- c(&quot;some&quot;, &quot;many&quot;, &quot;none&quot;, &quot;few&quot;) set9 &lt;- c(&quot;strings&quot;, &quot;random&quot;, &quot;some&quot;) # set7 == set8? setequal(set7, set8) #&gt; [1] FALSE # set7 == set9? setequal(set7, set9) #&gt; [1] TRUE 3.3.5 Exact equality with identical() Sometimes setequal() is not always what we want to use. It might be the case that you want to test whether two vectors are exactly equal (element by element). For instance, testing if set7 is exactly equal to set9. Although both vectors contain the same set of elements, they are not exactly the same vector. Such test can be performed with the function identical() # set7 identical to set7? identical(set7, set7) #&gt; [1] TRUE # set7 identical to set9? identical(set7, set9) #&gt; [1] FALSE If you consult the help documentation of identical(), you will see that this function is the “safe and reliable way to test two objects for being exactly equal”. 3.3.6 Element contained with is.element() If you wish to test if an element is contained in a given set of character strings you can do so with is.element(): # three vectors set10 &lt;- c(&quot;some&quot;, &quot;stuff&quot;, &quot;to&quot;, &quot;play&quot;, &quot;with&quot;) elem1 &lt;- &quot;play&quot; elem2 &lt;- &quot;crazy&quot; # elem1 in set10? is.element(elem1, set10) #&gt; [1] TRUE # elem2 in set10? is.element(elem2, set10) #&gt; [1] FALSE Alternatively, you can use the binary operator %in% to test if an element is contained in a given set. The function %in% returns TRUE if the first operand is contained in the second, and it returns FALSE otherwise: # elem1 in set10? elem1 %in% set10 #&gt; [1] TRUE # elem2 in set10? elem2 %in% set10 #&gt; [1] FALSE 3.3.7 Sorting with sort() The function sort() allows you to sort the elements of a vector, either in increasing order (by default) or in decreasing order using the argument decreasing: set11 = c(&quot;today&quot;, &quot;produced&quot;, &quot;example&quot;, &quot;beautiful&quot;, &quot;a&quot;, &quot;nicely&quot;) # sort (decreasing order) sort(set11) #&gt; [1] &quot;a&quot; &quot;beautiful&quot; &quot;example&quot; &quot;nicely&quot; &quot;produced&quot; &quot;today&quot; # sort (increasing order) sort(set11, decreasing = TRUE) #&gt; [1] &quot;today&quot; &quot;produced&quot; &quot;nicely&quot; &quot;example&quot; &quot;beautiful&quot; &quot;a&quot; If you have alpha-numeric strings, sort() will put the numbers first when sorting in increasing order: set12 = c(&quot;today&quot;, &quot;produced&quot;, &quot;example&quot;, &quot;beautiful&quot;, &quot;1&quot;, &quot;nicely&quot;) # sort (decreasing order) sort(set12) #&gt; [1] &quot;1&quot; &quot;beautiful&quot; &quot;example&quot; &quot;nicely&quot; &quot;produced&quot; &quot;today&quot; # sort (increasing order) sort(set12, decreasing = TRUE) #&gt; [1] &quot;today&quot; &quot;produced&quot; &quot;nicely&quot; &quot;example&quot; &quot;beautiful&quot; &quot;1&quot; 3.3.8 Repetition with paste(rep()) A very common operation with strings is replication, that is, given a string we want to replicate it several times. Although there is no single function in R for that purpose, we can combine paste() and rep() like so: # repeat &quot;x&quot; 4 times paste(rep(&quot;x&quot;, 4), collapse = &#39;&#39;) #&gt; [1] &quot;xxxx&quot; "],
["basics2.html", "4 Basic Manipulations with \"stringr\" Functions 4.1 Introduction 4.2 Package \"stringr\" 4.3 Basic String Operations", " 4 Basic Manipulations with \"stringr\" Functions 4.1 Introduction As we saw in the previous chapters, R provides a useful range of functions for basic string processing and manipulations of \"character\" data. Most of the times these functions are enough and they will allow us to get our job done. Sometimes, however, they have an awkward behavior. As an example, consider the function paste(). The default separator is a blank space, which more often than not is what we want to use. But that’s secondary. The really annoying thing is when we want to paste things that include zero length arguments. How does paste() behave in those cases? See below: # this works fine paste(&quot;University&quot;, &quot;of&quot;, &quot;California&quot;, &quot;Berkeley&quot;) #&gt; [1] &quot;University of California Berkeley&quot; # this works fine too paste(&quot;University&quot;, &quot;of&quot;, &quot;California&quot;, &quot;Berkeley&quot;) #&gt; [1] &quot;University of California Berkeley&quot; # this is weird paste(&quot;University&quot;, &quot;of&quot;, &quot;California&quot;, &quot;Berkeley&quot;, NULL) #&gt; [1] &quot;University of California Berkeley &quot; # this is ugly paste(&quot;University&quot;, &quot;of&quot;, &quot;California&quot;, &quot;Berkeley&quot;, NULL, character(0), &quot;Go Bears!&quot;) #&gt; [1] &quot;University of California Berkeley Go Bears!&quot; Notice the output from the last example (the ugly one). The objects NULL and character(0) have zero length, yet when included inside paste() they are treated as an empty string \"\". Wouldn’t be good if paste() removed zero length arguments? Sadly, there’s nothing we can do to change nchar() and paste(). But fear not. There is a very nice package that solves these problems and provides several functions for carrying out consistent string processing. 4.2 Package \"stringr\" Thanks to Hadley Wickham and company, we have the package \"stringr\" that adds more functionality to the base functions for handling strings in R. According to the description of the package http://cran.r-project.org/web/packages/stringr/index.html \"stringr\" is a set of simple wrappers that make R’s string functions more consistent, simpler and easier to use. It does this by ensuring that: function and argument names (and positions) are consistent, all functions deal with NA’s and zero length character appropriately, and the output data structures from each function matches the input data structures of other functions.\" To install \"stringr\" use the function install.packages(). Once installed, load it to your current session with library(): # installing &#39;stringr&#39; install.packages(&quot;stringr&quot;) # load &#39;stringr&#39; library(stringr) 4.3 Basic String Operations \"stringr\" provides functions for both 1) basic manipulations and 2) for regular expression operations. In this chapter we cover those functions that have to do with basic manipulations. The following table contains the \"stringr\" functions for basic string operations: Function Description Similar to str_c() string concatenation paste() str_length() number of characters nchar() str_sub() extracts substrings substring() str_dup() duplicates characters none str_trim() removes leading and trailing whitespace none str_pad() pads a string none str_wrap() wraps a string paragraph strwrap() str_trim() trims a string none Notice that all functions start with \"str_\" followed by a term associated to the task they perform. For example, str_length() gives you the number (i.e. length) of characters in a string. In addition, some functions are designed to provide a better alternative to already existing functions. This is the case of str_length() which is intended to be a substitute of nchar(). Other functions, however, don’t have a corresponding alternative such as str_dup() which allows you to duplicate characters. 4.3.1 Concatenating with str_c() Let’s begin with str_c(). This function is equivalent to paste() but instead of using the white space as the default separator, str_c() uses the empty string \"\" which is a more common separator when pasting strings: # default usage str_c(&quot;May&quot;, &quot;The&quot;, &quot;Force&quot;, &quot;Be&quot;, &quot;With&quot;, &quot;You&quot;) #&gt; [1] &quot;MayTheForceBeWithYou&quot; # removing zero length objects str_c(&quot;May&quot;, &quot;The&quot;, &quot;Force&quot;, NULL, &quot;Be&quot;, &quot;With&quot;, &quot;You&quot;, character(0)) #&gt; [1] &quot;MayTheForceBeWithYou&quot; Observe another major difference between str_c() and paste(): zero length arguments like NULL and character(0) are silently removed by str_c(). If you want to change the default separator, you can do that as usual by specifying the argument sep: # changing separator str_c(&quot;May&quot;, &quot;The&quot;, &quot;Force&quot;, &quot;Be&quot;, &quot;With&quot;, &quot;You&quot;, .sep = &quot;_&quot;) #&gt; [1] &quot;MayTheForceBeWithYou_&quot; # synonym function &#39;str_glue&#39; str_glue(&quot;May&quot;, &quot;The&quot;, &quot;Force&quot;, &quot;Be&quot;, &quot;With&quot;, &quot;You&quot;, .sep = &quot;_&quot;) #&gt; May_The_Force_Be_With_You As you can see from the previous examples, an alternative for str _() is str_glue() with the argument .sep. 4.3.2 Number of characters with str_length() As we’ve mentioned before, the function str_length() is equivalent to nchar(). Both functions return the number of characters in a string, that is, the length of a string (do not confuse it with the length() of a vector). Compared to nchar(), str_length() has a more consistent behavior when dealing with NA values. Instead of giving NA a length of 2, str_length() preserves missing values just as NAs. # some text (NA included) some_text &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, NA, &quot;five&quot;) # compare &#39;str_length&#39; with &#39;nchar&#39; nchar(some_text) #&gt; [1] 3 3 5 NA 4 str_length(some_text) #&gt; [1] 3 3 5 NA 4 In addition, str_length() has the nice feature that it converts factors to characters, something that nchar() is not able to handle: some_factor &lt;- factor(c(1,1,1,2,2,2), labels = c(&quot;good&quot;, &quot;bad&quot;)) some_factor #&gt; [1] good good good bad bad bad #&gt; Levels: good bad # try &#39;nchar&#39; on a factor nchar(some_factor) #&gt; Error in nchar(some_factor): &#39;nchar()&#39; requires a character vector # now compare it with &#39;str_length&#39; str_length(some_factor) #&gt; [1] 4 4 4 3 3 3 4.3.3 Substring with str_sub() To extract substrings from a character vector stringr provides str_sub() which is equivalent to substring(). The function str_sub() has the following usage form: str_sub(string, start = 1L, end = -1L) The three arguments in the function are: a string vector, a start value indicating the position of the first character in substring, and an end value indicating the position of the last character. Here’s a simple example with a single string in which characters from 1 to 5 are extracted: lorem &lt;- &quot;Lorem Ipsum&quot; # apply &#39;str_sub&#39; str_sub(lorem, start = 1, end = 5) #&gt; [1] &quot;Lorem&quot; # equivalent to &#39;substring&#39; substring(lorem, first = 1, last = 5) #&gt; [1] &quot;Lorem&quot; # another example str_sub(&quot;adios&quot;, 1:3) #&gt; [1] &quot;adios&quot; &quot;dios&quot; &quot;ios&quot; An interesting feature of str_sub() is its ability to work with negative indices in the start and end positions. When we use a negative position, str_sub() counts backwards from last character: resto = c(&quot;brasserie&quot;, &quot;bistrot&quot;, &quot;creperie&quot;, &quot;bouchon&quot;) # &#39;str_sub&#39; with negative positions str_sub(resto, start = -4, end = -1) #&gt; [1] &quot;erie&quot; &quot;trot&quot; &quot;erie&quot; &quot;chon&quot; # compared to substring (useless) substring(resto, first = -4, last = -1) #&gt; [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; Similar to substring(), we can also give str_sub() a set of positions which will be recycled over the string. But even better, we can give str_sub() a negative sequence, something that substring() ignores: # extracting sequentially str_sub(lorem, seq_len(nchar(lorem))) #&gt; [1] &quot;Lorem Ipsum&quot; &quot;orem Ipsum&quot; &quot;rem Ipsum&quot; &quot;em Ipsum&quot; &quot;m Ipsum&quot; #&gt; [6] &quot; Ipsum&quot; &quot;Ipsum&quot; &quot;psum&quot; &quot;sum&quot; &quot;um&quot; #&gt; [11] &quot;m&quot; substring(lorem, seq_len(nchar(lorem))) #&gt; [1] &quot;Lorem Ipsum&quot; &quot;orem Ipsum&quot; &quot;rem Ipsum&quot; &quot;em Ipsum&quot; &quot;m Ipsum&quot; #&gt; [6] &quot; Ipsum&quot; &quot;Ipsum&quot; &quot;psum&quot; &quot;sum&quot; &quot;um&quot; #&gt; [11] &quot;m&quot; # reverse substrings with negative positions str_sub(lorem, -seq_len(nchar(lorem))) #&gt; [1] &quot;m&quot; &quot;um&quot; &quot;sum&quot; &quot;psum&quot; &quot;Ipsum&quot; #&gt; [6] &quot; Ipsum&quot; &quot;m Ipsum&quot; &quot;em Ipsum&quot; &quot;rem Ipsum&quot; &quot;orem Ipsum&quot; #&gt; [11] &quot;Lorem Ipsum&quot; substring(lorem, -seq_len(nchar(lorem))) #&gt; [1] &quot;Lorem Ipsum&quot; &quot;Lorem Ipsum&quot; &quot;Lorem Ipsum&quot; &quot;Lorem Ipsum&quot; &quot;Lorem Ipsum&quot; #&gt; [6] &quot;Lorem Ipsum&quot; &quot;Lorem Ipsum&quot; &quot;Lorem Ipsum&quot; &quot;Lorem Ipsum&quot; &quot;Lorem Ipsum&quot; #&gt; [11] &quot;Lorem Ipsum&quot; We can use str_sub() not only for extracting subtrings but also for replacing substrings: # replacing &#39;Lorem&#39; with &#39;Nullam&#39; lorem &lt;- &quot;Lorem Ipsum&quot; str_sub(lorem, 1, 5) &lt;- &quot;Nullam&quot; lorem #&gt; [1] &quot;Nullam Ipsum&quot; # replacing with negative positions lorem &lt;- &quot;Lorem Ipsum&quot; str_sub(lorem, -1) &lt;- &quot;Nullam&quot; lorem #&gt; [1] &quot;Lorem IpsuNullam&quot; # multiple replacements lorem &lt;- &quot;Lorem Ipsum&quot; str_sub(lorem, c(1,7), c(5,8)) &lt;- c(&quot;Nullam&quot;, &quot;Enim&quot;) lorem #&gt; [1] &quot;Nullam Ipsum&quot; &quot;Lorem Enimsum&quot; 4.3.4 Duplication with str_dup() A common operation when handling characters is duplication. The problem is that R doesn’t have a specific function for that purpose. But stringr does: str_dup() duplicates and concatenates strings within a character vector. Its usage requires two arguments: str_dup(string, times) The first input is the string that you want to dplicate. The second input, times, is the number of times to duplicate each string: # default usage str_dup(&quot;hola&quot;, 3) #&gt; [1] &quot;holaholahola&quot; # use with differetn &#39;times&#39; str_dup(&quot;adios&quot;, 1:3) #&gt; [1] &quot;adios&quot; &quot;adiosadios&quot; &quot;adiosadiosadios&quot; # use with a string vector words &lt;- c(&quot;lorem&quot;, &quot;ipsum&quot;, &quot;dolor&quot;, &quot;sit&quot;, &quot;amet&quot;) str_dup(words, 2) #&gt; [1] &quot;loremlorem&quot; &quot;ipsumipsum&quot; &quot;dolordolor&quot; &quot;sitsit&quot; &quot;ametamet&quot; str_dup(words, 1:5) #&gt; [1] &quot;lorem&quot; &quot;ipsumipsum&quot; &quot;dolordolordolor&quot; #&gt; [4] &quot;sitsitsitsit&quot; &quot;ametametametametamet&quot; 4.3.5 Padding with str_pad() Another handy function that we can find in stringr is str_pad() for padding a string. Its default usage has the following form: str_pad(string, width, side = &quot;left&quot;, pad = &quot; &quot;) The idea of str_pad() is to take a string and pad it with leading or trailing characters to a specified total width. The default padding character is a space (pad = \" \"), and consequently the returned string will appear to be either left-aligned (side = \"left\"), right-aligned (side = \"right\"), or both (side = \"both\"). Let’s see some examples: # default usage str_pad(&quot;hola&quot;, width = 7) #&gt; [1] &quot; hola&quot; # pad both sides str_pad(&quot;adios&quot;, width = 7, side = &quot;both&quot;) #&gt; [1] &quot; adios &quot; # left padding with &#39;#&#39; str_pad(&quot;hashtag&quot;, width = 8, pad = &quot;#&quot;) #&gt; [1] &quot;#hashtag&quot; # pad both sides with &#39;-&#39; str_pad(&quot;hashtag&quot;, width = 9, side = &quot;both&quot;, pad = &quot;-&quot;) #&gt; [1] &quot;-hashtag-&quot; 4.3.6 Wrapping with str_wrap() The function str_wrap() is equivalent to strwrap() which can be used to wrap a string to format paragraphs. The idea of wrapping a (long) string is to first split it into paragraphs according to the given width, and then add the specified indentation in each line (first line with indent, following lines with exdent). Its default usage has the following form: str_wrap(string, width = 80, indent = 0, exdent = 0) For instance, consider the following quote (from Douglas Adams) converted into a paragraph: # quote (by Douglas Adams) some_quote &lt;- c( &quot;I may not have gone&quot;, &quot;where I intended to go,&quot;, &quot;but I think I have ended up&quot;, &quot;where I needed to be&quot;) # some_quote in a single paragraph some_quote &lt;- paste(some_quote, collapse = &quot; &quot;) Now, say you want to display the text of some_quote within some pre-specified column width (e.g. width of 30). You can achieve this by applying str_wrap() and setting the argument width = 30 # display paragraph with width=30 cat(str_wrap(some_quote, width = 30)) #&gt; I may not have gone where I #&gt; intended to go, but I think I #&gt; have ended up where I needed #&gt; to be Besides displaying a (long) paragraph into several lines, you may also wish to add some indentation. Here’s how you can indent the first line, as well as the following lines: # display paragraph with first line indentation of 2 cat(str_wrap(some_quote, width = 30, indent = 2), &quot;\\n&quot;) #&gt; I may not have gone where I #&gt; intended to go, but I think I #&gt; have ended up where I needed #&gt; to be # display paragraph with following lines indentation of 3 cat(str_wrap(some_quote, width = 30, exdent = 3), &quot;\\n&quot;) #&gt; I may not have gone where I #&gt; intended to go, but I think I #&gt; have ended up where I needed #&gt; to be 4.3.7 Trimming with str_trim() One of the typical tasks of string processing is that of parsing a text into individual words. Usually, you end up with words that have blank spaces, called whitespaces, on either end of the word. In this situation, you can use the str_trim() function to remove any number of whitespaces at the ends of a string. Its usage requires only two arguments: str_trim(string, side = &quot;both&quot;) The first input is the string to be strimmed, and the second input indicates the side on which the whitespace will be removed. Consider the following vector of strings, some of which have whitespaces either on the left, on the right, or on both sides. Here’s what str_trim() would do to them under different settings of side # text with whitespaces bad_text &lt;- c(&quot;This&quot;, &quot; example &quot;, &quot;has several &quot;, &quot; whitespaces &quot;) # remove whitespaces on the left side str_trim(bad_text, side = &quot;left&quot;) #&gt; [1] &quot;This&quot; &quot;example &quot; &quot;has several &quot; &quot;whitespaces &quot; # remove whitespaces on the right side str_trim(bad_text, side = &quot;right&quot;) #&gt; [1] &quot;This&quot; &quot; example&quot; &quot;has several&quot; &quot; whitespaces&quot; # remove whitespaces on both sides str_trim(bad_text, side = &quot;both&quot;) #&gt; [1] &quot;This&quot; &quot;example&quot; &quot;has several&quot; &quot;whitespaces&quot; 4.3.8 Word extraction with word() We end this chapter describing the word() function that is designed to extract words from a sentence: word(string, start = 1L, end = start, sep = fixed(&quot; &quot;)) The way in which you use word() is by passing it a string, together with a start position of the first word to extract, and an end position of the last word to extract. By default, the separator sep used between words is a single space. Let’s see some examples: # some sentence change &lt;- c(&quot;Be the change&quot;, &quot;you want to be&quot;) # extract first word word(change, 1) #&gt; [1] &quot;Be&quot; &quot;you&quot; # extract second word word(change, 2) #&gt; [1] &quot;the&quot; &quot;want&quot; # extract last word word(change, -1) #&gt; [1] &quot;change&quot; &quot;be&quot; # extract all but the first words word(change, 2, -1) #&gt; [1] &quot;the change&quot; &quot;want to be&quot; \"stringr\" has more functions but we’ll discuss them in the chapters about regular expressions. "]
]
